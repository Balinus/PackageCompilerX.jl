<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Apps · PackageCompilerX</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.8.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.8.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.8.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PackageCompilerX</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../prereq/">Prerequisites</a></li><li><a class="tocitem" href="../sysimages/">Sysimages</a></li><li class="is-active"><a class="tocitem" href>Apps</a><ul class="internal"><li><a class="tocitem" href="#Relocatability-1"><span>Relocatability</span></a></li><li><a class="tocitem" href="#Creating-an-app-1"><span>Creating an app</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/ohmyrepl/">Creating a sysimage with OhMyREPL</a></li></ul></li><li><a class="tocitem" href="../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Apps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Apps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KristofferC/PackageCompilerX.jl/blob/master/docs/src/apps.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Apps-1">Apps<a class="docs-heading-anchor" href="#Apps-1" title="Permalink"></a></h1><p>With an &quot;app&quot; we here mean a bundle of files where one of these files is an executable and where the bundle can be sent to another machine while still allowing the executable to run.</p><p>Use cases for Julia-apps is for example when one wants to provide some kind of functionality where the fact that it was written in Julia is just an implementation detail and forcing the user to download and use Julia to run the code would be a distraction. There is also no need to provide the original Julia source code for apps since everything gets baked into the sysimage.</p><h2 id="Relocatability-1">Relocatability<a class="docs-heading-anchor" href="#Relocatability-1" title="Permalink"></a></h2><p>Since we want to send the app to other machines the app we create must be &quot;relocatable&quot;.  With an app being &quot;relocatable&quot; we mean it does not rely on specifics of the machine where the app was created.  Relocatability is not an absolute measure, most apps assume some properties of the machine they will run on, like what operating system is installed and the presence of graphics drivers if one want to show graphics. On the other hand, embedding things into the app that is most likely unique to the machine, like absolute paths, means that the application almost surely will not run properly on another machine.</p><p>For something to be relocatable, everything that it depends on must also be relocatable.  In the case of an app, the app itself and all the Julia packages it depends on must also relocatable. This is a bit of an issue because the Julia package ecosystem has not thought much about relocatability since app making has not been common in the Julia community. </p><p>The main problem with relocatability of Julia packages is that many packages are encoding fundamentally non-relocatable <em>into the source code</em>.  As an example, many packages tend to use a <code>build.jl</code> file (which runs when the package is first installed) that looks something like:</p><pre><code class="language-none">lib_path = find_library(&quot;libfoo&quot;)
write(&quot;deps.jl&quot;, &quot;const LIBFOO_PATH = $(repr(lib_path))&quot;)</code></pre><p>The main package file then contains</p><pre><code class="language-none">if !isfile(&quot;../build/deps.jl&quot;)
    error(&quot;run Pkg.build(\&quot;Package\&quot;) to re-build Package&quot;)
end
include(&quot;../build/deps.jl&quot;)
function __init__()
    libfoo = Libdl.dlopen(LIBFOO_PATH)
end
</code></pre><p>The absolute path to <code>lib_path</code> that <code>find_library</code> found is thus effectively included into the source code of the package. Arguably, the whole build system in Julia is inherently non-relocatable because it runs when the package is being installed which is a concept that doesn&#39;t make sense when distributing an app.</p><p>Some packages do need to call into external libraries and use external binaries so how are these packages supposed to do this in a relocatable way?  The answer is to use the &quot;artifact system&quot; which was described in the following [blog post][artifact-blog-url]. The artifact system is a declarative way of downloading and using &quot;external files&quot; like binaries and libraries.  How this is used in practice is described a bit later in this document.</p><h2 id="Creating-an-app-1">Creating an app<a class="docs-heading-anchor" href="#Creating-an-app-1" title="Permalink"></a></h2><p>The source of an app is a package with a project and manifest file. It should define a function with the signature</p><pre><code class="language-jl">Base.@ccallable function julia_main()::Cint
  ...
end</code></pre><p>which will be the entry point of the app (the function that runs when the executable in the app is run). A skeleton of an app to start working from can be found at https://github.com/KristofferC/PackageCompilerX.jl/tree/master/examples/MyApp.</p><p>Regarding relocatability, PackageCompilerX provides a function <a href="../refs/#PackageCompilerX.audit_app"><code>audit_app(app_dir::String)</code></a> that tries to find common problems with relocatability in the app. </p><p>The app is then compiled using the <a href="../refs/#PackageCompilerX.create_app"><code>create_app</code></a> function that takes a path to the source code of the app and the destination where the app should be compiled to. This will bundle all required libraries for the app to run on another machine where the same Julia that created the app could run.  As an example, below the example app linked above is compiled and run:</p><pre><code class="language-none">~/PackageCompilerX.jl/examples
❯ julia -q --project

julia&gt; using PackageCompilerX

julia&gt; create_app(&quot;MyApp/&quot;, &quot;MyAppCompiled&quot;)
[ Info: PackageCompilerX: creating base system image (incremental=false), this might take a while...
[ Info: PackageCompilerX: creating system image object file, this might take a while...

julia&gt; exit()

~/PackageCompilerX.jl/examples
❯ MyAppCompiled/bin/MyApp
ARGS = [&quot;foo&quot;, &quot;bar&quot;]
Base.PROGRAM_FILE = &quot;MyAppCompiled/bin/MyApp&quot;
...
ἔοικα γοῦν τούτου γε σμικρῷ τινι αὐτῷ τούτῳ σοφώτερος εἶναι, ὅτι ἃ μὴ οἶδα οὐδὲ οἴομαι εἰδέναι.
unsafe_string((Base.JLOptions()).image_file) = &quot;/home/kc/PackageCompilerX.jl/examples/MyAppCompiled/bin/MyApp.so&quot;
Example.domath(5) = 10
sin(0.0) = 0.0</code></pre><p>The resulting executable is found in the <code>bin</code> folder in the compiled app directory.  The compiled app directory <code>MyAppCompiled</code> could now be put into an archive and sent to another machine or an installer could be wrapped around the directory, perhaps providing a better user experience than just an archive of files.</p><h3 id="Precompilation-1">Precompilation<a class="docs-heading-anchor" href="#Precompilation-1" title="Permalink"></a></h3><p>In the same way as files for precompilation could be given when creating sysimages, the same keyword arguments are used to add precompilation to apps.</p><h3 id="Incremental-vs-non-incremental-sysimage-1">Incremental vs non-incremental sysimage<a class="docs-heading-anchor" href="#Incremental-vs-non-incremental-sysimage-1" title="Permalink"></a></h3><p>In the section about creating sysimages, there was a short discussion about incremental vs non-incremental sysimages. In short, an incremental sysimage is built on top of another sysimage while a non-incremental is created from scratch. For sysimages, it made sense to use an incremental sysimage built on top of Julia&#39;s default sysimage since we wanted the benefit of having a snappy REPL that it provides.  For apps, this is no longer the case, the sysimage is not meant to be used when working interactively, it only needs to be specialized for the specific app.  Therefore, by default, <code>incremental=true</code> is used for <code>create_app</code>. If, for some reason, one wants an incremental sysimage, <code>incremental=true</code> could be passed to <code>create_app</code>.  With the example app, a non-incremental sysimage is about 70MB smaller than the default sysimage.</p><h3 id="Filtering-stdlibs-1">Filtering stdlibs<a class="docs-heading-anchor" href="#Filtering-stdlibs-1" title="Permalink"></a></h3><p>By default, all standard libraries are included in the sysimage.  It is possible to only include those standard libraries that the project needs by passing the keyword argument <code>filter_stdlibs=true</code> to <code>create_app</code>.  This causes the sysimage to be smaller, and possibly load faster.  The reason this is not the default is that it is possible to &quot;accidentally&quot; depend on a standard library without it being reflected in the Project file.  For example, it is possible to call <code>rand()</code> from a package without depending on Random, even though that is where it is defined. If Random was excluded from the sysimage that call would then error. Same applies to matrix multiplication, <code>rand(3,3) * rand(3,3)</code> requires both <code>LinearAlgebra</code> and <code>Random</code> This is because these standard libraries do &quot;type piracy&quot; so just loading them can cause code to change behavior.</p><p>Nevertheless, the option is there to use, just make sure to properly test the app with the resulting sysimage.</p><h3 id="Artifacts-1">Artifacts<a class="docs-heading-anchor" href="#Artifacts-1" title="Permalink"></a></h3><p>The way to depend on external libraries or binaries when creating apps is by using the [artifact system][artifact-pkg-url]. PackageCompilerX will bundle all artifacts needed by the project, and set up things so that they can be found during runtime on other machines.</p><p>The example app uses the artifact system to depend on a very simple toy binary that prints some greek text. It is instructive to see how the <a href="https://github.com/KristofferC/PackageCompilerX.jl/blob/d12d8d9b2286bb7d57ca28ad0f2a8cd130c70c81/examples/MyApp/Artifacts.toml">artifact file</a> is <a href="https://github.com/KristofferC/PackageCompilerX.jl/blob/d12d8d9b2286bb7d57ca28ad0f2a8cd130c70c81/examples/MyApp/src/MyApp.jl#L4-L7">used in the source code</a></p><h3 id="What-things-are-being-leaked-about-the-build-machine-and-the-source-code-1">What things are being leaked about the build machine and the source code<a class="docs-heading-anchor" href="#What-things-are-being-leaked-about-the-build-machine-and-the-source-code-1" title="Permalink"></a></h3><p>While the created app is relocatable and no source code is bundled with it, there are still some things about the build machine that can be observed.</p><h4 id="Absolute-paths-of-build-machine-1">Absolute paths of build machine<a class="docs-heading-anchor" href="#Absolute-paths-of-build-machine-1" title="Permalink"></a></h4><p>Julia records the paths and line-numbers for methods when they are getting compiled.  These get cached into the sysimage and can be found e.g. by dumping all strings in the sysimage:</p><pre><code class="language-none">~/PackageCompilerX.jl/examples/MyAppCompiled/bin
❯ strings MyApp.so | grep MyApp
MyApp
/home/kc/PackageCompilerX.jl/examples/MyApp/
MyApp
/home/kc/PackageCompilerX.jl/examples/MyApp/src/MyApp.jl
/home/kc/PackageCompilerX.jl/examples/MyApp/src
MyApp.jl
/home/kc/PackageCompilerX.jl/examples/MyApp/src/MyApp.jl</code></pre><p>This is a problem that Julia itself has:</p><pre><code class="language-none">julia&gt; @which rand()
rand() in Random at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.3/Random/src/Random.jl:256</code></pre><h4 id="Using-reflection-and-finding-lowered-code-1">Using reflection and finding lowered code<a class="docs-heading-anchor" href="#Using-reflection-and-finding-lowered-code-1" title="Permalink"></a></h4><p>There is nothing preventing someone from starting Julia with the sysimage that comes with the app.  And while the source code is not available one can read the &quot;lowered code&quot; and use reflection to find things like the name of fields in structs and global variables etc:</p><pre><code class="language-none">~/PackageCompilerX.jl/examples/MyAppCompiled/bin kc/docs_apps*
❯ julia -q -JMyApp.so
julia&gt; MyApp = Base.loaded_modules[Base.PkgId(Base.UUID(&quot;f943f3d7-887a-4ed5-b0c0-a1d6899aa8f5&quot;), &quot;MyApp&quot;)]
MyApp

julia&gt; names(MyApp; all=true)
10-element Array{Symbol,1}:
 Symbol(&quot;#eval&quot;)
 Symbol(&quot;#include&quot;)
 Symbol(&quot;#julia_main&quot;)
 Symbol(&quot;#real_main&quot;)
 :MyApp
 :eval
 :include
 :julia_main
 :real_main
 :socrates

julia&gt; @code_lowered MyApp.real_main()
CodeInfo(
1 ─ %1  = MyApp.ARGS
│         value@_2 = %1
│   %3  = Base.repr(%1)
│         Base.println(&quot;ARGS = &quot;, %3)
│         value@_2
│   %6  = Base.PROGRAM_FILE
│         value@_3 = %6
│   %8  = Base.repr(%6)
│         Base.println(&quot;Base.PROGRAM_FILE = &quot;, %8)
│         value@_3
│   %11 = MyApp.DEPOT_PATH</code></pre><p>[artifact-blog-url]: https://julialang.org/blog/2019/11/artifacts [artifact-pkg-url]: https://julialang.github.io/Pkg.jl/v1/artifacts/</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sysimages/">« Sysimages</a><a class="docs-footer-nextpage" href="../examples/ohmyrepl/">Creating a sysimage with OhMyREPL »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 11 December 2019 12:41">Wednesday 11 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
