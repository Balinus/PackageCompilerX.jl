var documenterSearchIndex = {"docs":
[{"location":"examples/ohmyrepl/#Creating-a-sysimage-with-OhMyREPL-1","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"","category":"section"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"OhMyREPL.jl is a package that enhances the REPL with, for example, syntax highlighting. It does, however, come with a bit of a startup time increase so compiling a new system image with OhMyREPL included is useful. Importing the OhMyREPL package is not the only factor that contributes to the extra load time from using OhMyREPL In addition, the time of compiling functions that OhMyREPL uses is also a factor. Therefore, we also want to do Profile Guided Precompilation (PGP) where we record what functions gets compiled when using OhMyREPL so they can be cached into the system image. OhMyREPL is a bit different from most other packages in that is used interactive. Normally to do PGP with PackageCompilerX we pass a script to to execute as the precompile_exectution_file which is used to collect compilation data,  but in this case, we will use Julia to manually collect this data.","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"First install OhMyREPL in the global environement using import Pkg; Pkg.add(\"OhMyREPL\"). Run using OhMyREPL and write something (like 1+1). It should be syntax highlighted but you might have noticed that there was a bit of a delay before the characters appeared. This is the extra latency from using the package that we want to get rid off.","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"(Image: OhMyREPL installation)","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"The first goal is to have Julia emit the functions it compiles when running OhMyREPL. To this end, start Julia with the --trace-compile=ohmyrepl_precompile flag. This will start a normal-looking Julia session but all functions that get compiled are output to the file ohmyrepl_precompile. In the Julia session, load OhMyREPL, use the REPL a bit so that the functionality of OhMyREPL is exercised. Quit Julia and look into the file ohmyrepl_precompile. It should be filled with lines like:","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"precompile(Tuple{typeof(OhMyREPL.Prompt.insert_keybindings), Any})\nprecompile(Tuple{typeof(OhMyREPL.__init__)})","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"This are functions that Julia compile. We now just tell create_sysimage to use these precompile statements when creating the system image:","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"PackageCompilerX.create_sysimage(:OhMyREPL; precompile_statements_file=\"ohmyrepl_precompile\", replace_default=true)","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"Restart julia and start typing something. If everything went well you should see the type text become highlighted with a significantly smaller delay than before creating the new system image","category":"page"},{"location":"examples/ohmyrepl/#","page":"Creating a sysimage with OhMyREPL","title":"Creating a sysimage with OhMyREPL","text":"note: Note\nIf you want to go back to the default sysimage you can runPackageCompilerX.restore_default_sysimage()","category":"page"},{"location":"prereq/#Prerequisites-1","page":"Prerequisites","title":"Prerequisites","text":"","category":"section"},{"location":"prereq/#","page":"Prerequisites","title":"Prerequisites","text":"In order to use this package you need either gcc or clang installed and on the path.","category":"page"},{"location":"prereq/#","page":"Prerequisites","title":"Prerequisites","text":"The package currently only works on Linux and Windows 64 bit.","category":"page"},{"location":"prereq/#","page":"Prerequisites","title":"Prerequisites","text":"In the future, we hope to avoid this by automatically providing a working compiler with the package.","category":"page"},{"location":"sysimages/#Sysimages-1","page":"Sysimages","title":"Sysimages","text":"","category":"section"},{"location":"sysimages/#What-is-a-sysimage-1","page":"Sysimages","title":"What is a sysimage","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"A sysimage is a file which, in a loose sense, contains a Julia session serialized to a file.  A \"Julia session\" include things like loaded packages, global variables, inferred and compiled code, etc.  By starting Julia with a sysimage, the stored Julia session is deserialized and loaded. The idea behind the sysimage is that this deserialization is faster than having to reload packages and recompile code from scratch.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Julia ships with a sysimage that is used by default when Julia is started. That sysimage contains the Julia compiler itself, the standard libraries and also compiled code (precompile statements) that has been put there to reduce the time required to do common operations, like working in the REPL.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Sometimes, it is desirable to create a custom sysimage with custom precompile statements. This is the case if one has some dependencies that take a significant time to load or where the compilation time for the first call is uncomfortably long. This section of the documentation is intended to document how to use PackageCompilerX to create such sysimages.","category":"page"},{"location":"sysimages/#Drawbacks-to-custom-sysimages-1","page":"Sysimages","title":"Drawbacks to custom sysimages","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"It should be clearly stated that there are some drawbacks to using a custom sysimage, thereby sidestepping the standard Julia package precompilation system.  The biggest drawback is that packages that are compiled into a sysimage (including their dependencies!) are \"locked\" to the version they where at when the sysimage was ( created.  This means that no matter what package version you have installed in your current project, the one in the sysimage will take precedence. This can lead to bugs where you start with a project that needs a specific version of a package, but you have another one compiled into the sysimage. ","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Putting packages in the sysimage is therefore only recommended if the load time of the packages getting put in there is a significant problem and that these are not frequently updated. In addition, compiling \"workflow packages\" like Revise.jl and OhMyREPL.jl might make sense.","category":"page"},{"location":"sysimages/#Creating-a-sysimage-using-PackageCompilerX-1","page":"Sysimages","title":"Creating a sysimage using PackageCompilerX","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"PackageCompilerX provides the function create_sysimage to create a sysimage.  It takes as the first argument a package or a list of packages that should be embedded in the resulting sysimage. By default, the given packages are loaded from the active project but a specific project can be specified by giving a path with the project keyword. The location of the resulting sysimage is given by the sysimage_path keyword.  After the sysimage is created, giving the command flag -Jpath/to/sysimage will start Julia with the given sysimage.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"As an example, below, a new sysimage in a separate project is created with the package Example.jl in it. Using Base.loaded_modules it can be seen that the package is loaded without having to explicitly import it. ","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~\n❯ mkdir NewSysImageEnv\n\n~\n❯ cd NewSysImageEnv\n\n~/NewSysImageEnv 29s\n❯ julia -q\n\njulia> using PackageCompilerX\n[ Info: Precompiling PackageCompilerX [dffaa6cc-da53-48e5-b007-4292dfcc27f1]\n\n(v1.3) pkg> activate .\nActivating new environment at `~/NewSysImageEnv/Project.toml`\n\n(NewSysImageEnv) pkg> add Example\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Resolving package versions...\n  Updating `~/NewSysImageEnv/Project.toml`\n  [7876af07] + Example v0.5.3\n  Updating `~/NewSysImageEnv/Manifest.toml`\n  [7876af07] + Example v0.5.3\n\njulia> create_sysimage(:Example; sysimage_path=\"ExampleSysimage.so\")\n[ Info: PackageCompilerX: creating system image object file, this might take a while...\n\njulia> exit()\n\n~/NewSysImageEnv\n❯ ls\nExampleSysimage.so  Manifest.toml  Project.toml\n\n~/NewSysImageEnv\n❯ julia -q -JExampleSysimage.so\n\njulia> Base.loaded_modules\nDict{Base.PkgId,Module} with 34 entries:\n...\n  Example [7876af07-990d-54b4-ab0e-23690620f79a]          => Example\n...","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Alternatively, instead of giving a path to where the new sysimage should appear, one can choose to replace the default sysimage. This is done by omitting the sysimage_path keyword and instead adding replace_default=true, for example:","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"create_sysimage([:Debugger, :OhMyREPL]; replace_default=true)","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"If this is the first time create_sysimage is called with replace_default, a backup of the default sysimage is created. The default sysimage can then be restored with restore_default_sysimg().","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Note that sysimages are created \"incrementally\" in the sense that they add to the sysimage of the process running PackageCompilerX. If the default sysimage has been replaced, the next create_sysimage call will create a new sysimage based on the replaced sysimage. It is possible to create a sysimage non-incrementally by passing the incremental=false keyword. This will create a new system image from scratch, however, it will lose the special precompilation that the Julia bundled sysimage provides which is what make the REPL and package manager snappy. It is therefore unlikely that incremental=false is of much use unless in special cases for sysimage creation (for apps it is a different story though).","category":"page"},{"location":"sysimages/#Precompilation-1","page":"Sysimages","title":"Precompilation","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"The step where we included Example.jl in the sysimage meant that loading Example is now pretty much instant (the package is already loaded when Julia starts). However, functions inside Example.jl still need to be compiled when executed for the first time.  One way we can see this is by using the --trace-compile=stderr flag which outputs a \"precompile statement\" every time Julia compiles a function.  Running the hello function inside Example.jl we can see that it needs to be compiled (it shows the function Example.hello was compiled for the input type String.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~/NewSysImageEnv\n❯ julia -JExampleSysimage.so --trace-compile=stderr -e 'import Example; Example.hello(\"friend\")'\nprecompile(Tuple{typeof(Example.hello), String})","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"To remedy this, we can give a \"precompile script\" to create_sysimage which causes functions executed in that script to be baked into the sysimage. As an example, the script below simply calls the hello function in Example:","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~/NewSysImageEnv\n❯ cat precompile_example.jl\nusing Example\nExample.hello(\"friend\")","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"We now create a new system image called ExampleSysimagePrecompile.so where the precompile_statements_file keyword argument has been giving, pointing to the file just shown above:","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~/NewSysImageEnv\n❯ julia-q\n\njulia> using PackageCompilerX\n\n(v1.3) pkg> activate .\nActivating environment at `~/NewSysImageEnv/Project.toml`\n\njulia> PackageCompilerX.create_sysimage(:Example; sysimage_path=\"ExampleSysimagePrecompile.so\",\n                                         precompile_statements_file=\"precompile_example.jl\")\n[ Info: PackageCompilerX: creating system image object file, this might take a while...\n\njulia> exit()","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Using the just created system image, we can see that the hello function no longer needs to get compiled_:","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"~/NewSysImageEnv\n❯ julia -JExampleSysimagePrecompile.so --trace-compile=stderr -e 'import Example; Example.hello(\"friend\")'\n\n~/NewSysImageEnv\n❯","category":"page"},{"location":"sysimages/#Using-a-manually-generated-list-of-precompile-statements-1","page":"Sysimages","title":"Using a manually generated list of precompile statements","text":"","category":"section"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"Starting Julia with --trace-compile=file.jl will emit precompilation statements to file.jl for the duration of the started Julia process.  This can be useful in cases where it is difficult to give a script that executes the code (like with interactive use). A file with a list of such precompile statements can be used when creating a sysimage by passing the keyword argument precompile_statements_file. See the OhMyREPL.jl example in the docs for more details on how to use --trace-compile with PackageCompilerX.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"It is also possible to use [SnoopCompile.jl][snoop-url] to create files with precompilation statements.","category":"page"},{"location":"sysimages/#","page":"Sysimages","title":"Sysimages","text":"[snoop-url]: https://timholy.github.io/SnoopCompile.jl/stable/snoopi/#auto-1","category":"page"},{"location":"#PackageCompilerX-1","page":"Home","title":"PackageCompilerX","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"PackageCompilerX is a Julia package with two main purposes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Creating custom sysimages for reduced latency when working locally with packages that has a high startup time.\nCreating \"apps\" which are a bundle of files including an executable that can be sent and run on other machines without Julia being installed on that machine.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The manual contains some uses of Linux commands like ls (dir in Windows) and cat but hopefully these commands are common enough that the points still come across).","category":"page"},{"location":"#Manual-Outline-1","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"prereq.md\",\n    \"sysimages.md\",\n    \"apps.md\",\n    \"examples/ohmyrepl.md\",\n]\nDepth = 1","category":"page"},{"location":"refs/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"refs/#","page":"References","title":"References","text":"PackageCompilerX.create_sysimage\nPackageCompilerX.restore_default_sysimg\nPackageCompilerX.create_app\nPackageCompilerX.audit_app","category":"page"},{"location":"refs/#PackageCompilerX.create_sysimage","page":"References","title":"PackageCompilerX.create_sysimage","text":"create_sysimage(packages; sysimage_path, project, precompile_execution_file, precompile_statements_file, incremental, filter_stdlibs, replace_defaut)\n\n\n\n\n\n\n","category":"function"},{"location":"refs/#PackageCompilerX.restore_default_sysimg","page":"References","title":"PackageCompilerX.restore_default_sysimg","text":"restore_default_sysimg()\n\n\nlalala\n\n\n\n\n\n","category":"function"},{"location":"refs/#PackageCompilerX.create_app","page":"References","title":"PackageCompilerX.create_app","text":"create_app(package_dir, app_dir; precompile_execution_file, precompile_statements_file, incremental, filter_stdlibs, audit, force)\n\n\n\n\n\n\n","category":"function"},{"location":"refs/#PackageCompilerX.audit_app","page":"References","title":"PackageCompilerX.audit_app","text":"audit_app(project_dir)\n\n\nCheck for possible problems with regfards to relocatability at  the project at project_dir.\n\nwarning: Warning\nThis cannot guarantee that the project is free of relocatability problems, it can only detect some known bad cases and warn about those.\n\n\n\n\n\n","category":"function"},{"location":"apps/#Apps-1","page":"Apps","title":"Apps","text":"","category":"section"},{"location":"apps/#Relocatability-1","page":"Apps","title":"Relocatability","text":"","category":"section"},{"location":"apps/#Artifacts-1","page":"Apps","title":"Artifacts","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"PackageCompilerX provdes a function audit_app(project::String)[@ref] that tries to find common problems","category":"page"},{"location":"apps/#Incremental-vs-non-incremental-sysimage-1","page":"Apps","title":"Incremental vs non-incremental sysimage","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"Creating a sysimage can in PackageCompilerX either be done \"from scratch\" (incremental=false) or it can be done as a ","category":"page"},{"location":"apps/#Incremental-vs-non-incremental-sysimages-1","page":"Apps","title":"Incremental vs non-incremental sysimages","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"By default, when creating a sysimage with PackageCompilerX, the sysimage is created in \"incremental\"-mode. This means that the  This has the benefit that ","category":"page"},{"location":"apps/#Standard-library-filtering-1","page":"Apps","title":"Standard library filtering","text":"","category":"section"},{"location":"apps/#","page":"Apps","title":"Apps","text":"As an example, ","category":"page"},{"location":"apps/#What-things-are-being-leaked-1","page":"Apps","title":"What things are being leaked","text":"","category":"section"},{"location":"apps/#Absolute-paths-of-build-machine-1","page":"Apps","title":"Absolute paths of build machine","text":"","category":"section"},{"location":"apps/#Lowered-code-1","page":"Apps","title":"Lowered code","text":"","category":"section"},{"location":"apps/#Name-and-fieldname-of-types-1","page":"Apps","title":"Name and fieldname of types","text":"","category":"section"}]
}
